개발자 도구 활용
div(header) - {1200 x 113} - flex, margin : 0px auto;
    h1 - backgroud- gmarket 로고 -(header h1{ 240x 113}) - backgroud : url(); backgroud-size: 240px 113px
                                 backgroud-position : -40,0;  display : inline-block, position:relative;
    div(search) 
        input, button - .header .serch{ display : inline-block, width:553px; height: 48pxl vertical-align:top; border:2px solid #, border-radius : 24px, 
                                                margin-top 49px, margin-left:-45px, box-sizing : border-box}
                  .header .search input { width:480px; margin-top : 10px; font-size:16px; color:, line-height:29px; margin-left:20px; border:0; outline:-, }                              
                  .header .search button { width:22px; height:22px; backgroud(url), backgroud-size; border 0; margin-top: 10px; maring-left:1px }
    div(user-menu)  
        button(profile) - .header .user-menu { width:220px; height:80px, position:absolute; left:980px;}
        button(recent)
        button(cart)

css - * { margin:0; padding:0}
      .header > *{
          display : inline-block
          vertical-align:top;
      }



8.31
icon ㅎㅐ보기  
div(navigation) - .top-menu{ width : 1200px; height:60px; maring:0px auto}
    .navigation .category{ width:224px; height:60px; padding-top : 20px; padding-left:30px; } 
    .navigation .category::before{ content:'xxx'; height:26px; height:21px;, backgroud:url(); backgroud-position: -252px -40px; backgroud-size:400px auto; display:inline-block;}       
    .navigation .service-all ul{ list-style:none;}
    .navigation .service-all ul li{ display:inline-block; }
    
09.01
바깥쪽에 감싸과 읶는 친구ㅏ 있더라도 넘치면 표시해준다. -> 이때 overflow:hidden 을 주면 부모 컨텐츠 크기에 맞춰서 보여준다. 
지금 제일 잘 나가는 상품 - > scale()
데이터를 가져오는데 

overflow - 넘치는 것을 어떤 속성을 줄 건지.
transition - 부드럽게 할 수 있다. 
scale(1.1)  - 확대, 축소    (제일 잘 나가는 상품)
span(글시체의 크기와 폰트가 서로 다르는데 같은 단계에 있을 때)

09.03
server.js  -> http (require), server=http.createServer((req,res)=>{console.log(request), writeHead(상태태ㄱ코코드드), write를 사용하여 정보 전달 가능, 그리고 end로 끝맺음})
            server.listen(9999);    
            let filepath= request.url.substr(1)
            fs(require) fs.readFile(filepath, (err,data)=>{
                여기 안에서 writeHead(200);
            })
sdk (server developmetn kit)
response header  : nodejs의 http에서 기본적으로 제공해주는 정보들
웹 서버 = 웹 서버 + was     -> 로직을 돌려주는 
apache, nginx : 달라는 것 그대로 주는 서버 (static resouce) : was 앞에서 정적 리소스를 해주고 
was (web application server) : tomcat
프락시?
요청을 보면 파일의 경로이기 때문에 요청이 올 때 경로에 있는 파일을 읽어 
substr, substring
싱크 - 파일을 다 읽고 거기서 함수에서 리턴해주는 것 (x) => 함수가 리턴하기 전까지 아무것도 하지 않고 가만히 있는것
response headers = content-type 응답헤더를 ㅅ주지 않으면 안됨. 값을 꼭 줘야함. 라이브러리가 있음.
호스팅 : 어디에다 올려놔도        하나의 서버에서 여러 사람들이 같이 사용. 서버를 통째로 빌려주는 것
서버 : 고정 ip있으면 24시간 켜놓으면 웹서비스,   클라우드 (vm)

이미지를 js로 
    이미지가 js의 배열에 있고 출력한다. main.html의 ulf를 
처음부터 디비를 연결하면 힘들기 때문에 목(mock)데이터를 사용해서 프로그램을 실행시킨다. 